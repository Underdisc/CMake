# CMake
This repository contains information and samples on how to use CMake on a basic level to build projects.

##### Why CMake is Useful
CMake is essentially a wrapper around a typical Makefile. Though a Makefile is a good step to building a project quickly, `CMake takes that to the next level by writing the Makefile for you`, therefore automating the build process even more.

##### How to use this tutorial
In this repository, there should be multiple directories named 1, 2, and so on. Each directory covers a different part of CMake and how to use it effectively. In this tutorial, I will go through the important information each of these directories contains so you can quickly get started with CMake.

*A Quick Disclaimer: While writing this tutorial I am learning CMake myself, but I figure that writing a tutorial while I learn the information will help me better understand how CMake is used and how it works. On top of that, if anyone is looking to learn how to use CMake, I can point them to this repository. With that said, if anyone has any corrections for me to make, please point them out to me so I can make those changes for myself and others.*

#### Part 1 - Basic
To begin look in **1/**. As with learning how to create a Makefile for the first time, I figure it is best to start by learning how to use CMake with one file. In **1/**, you will find two files and one directory.

- program.c
- CMakeLists.txt
- build

If the build directory is not there, just create it with `mkdir build`. program.c is just the source for this program and only contains a printf statement. CMakeLists.txt however contains the directions for CMake to use in order to create a Makefile for the project.
If you open up CMakeLists.txt, you will find one line.

```
add_executable(program_name program.c)
```

This command adds a new executable target to your Makefile to be built. The first argument to this command is the name of the executable target. In this case, the target's name is `program_name`. The second argument is the file needed to build that target; `program.c`. This is the only line you need to have in order to build a Makefile for this simple program using CMake. This leads to a few questions, the most important of which is; **Which compiler will be used since we did not provide the information?** CMake will automatically figure out which compiler to use based off of the file extentions in your project. This can also be changed, but I will cover that later in this tutorial.

Now, the next step is to generate a Makefile with CMake and build the project. To do this, go to the empty directory **1/build/**. This directory is here to separate everything needed for building the project from your source code. From here run the following.

```
cmake ..
```

Here, we are running cmake on the parent director. Within the parent directory is where our CMakeLists.txt file is located. CMake used that file in order to create the Makefile that you should now see within your build directory. Now you can do the following.

```
make
./program_name
```

The program should have built successfully and ran. You might also notice that CMake adds some very pretty output to the build process as well.

#### Part 2 - Multiple Files and Flags

Now, go out of **1/** and move to **2/** for the next step. Unlike the directory used for part 1, here you should find 3 files and 1 directory.

- program.c
- more_program.c
- CMakeLists.txt
- build

Like last time, if you do not see a build directory, just use `mkdir build` to create it. Now open up **CMakeLists.txt** in this directory. In this CMakeLists.txt file, you should see an edit and a few additions from the CMakeLists.txt displayed in part one. The first thing to break down in this file is the very last line (7).

```
add_executable(program_name program.c more_program.c)
```

This is almost exactly the same as the `add_executable()` command in the previous CMakeLists.txt file, however it contains the name of the new file used in this project; **more_program.c**. This does exactly as you might think. The new file will be added to the Makefile generated by CMake, therefore allowing **more_program.c** to be compiled into an object file and linked with the object file created from **program.c** for the final executable.

The more insteresting part of this CMakeLists.txt file is what is located above the add_executable() command. On **lines 3-5** you will find the following.

```
3. add_definitions(${MY_C_FLAGS})
4. set(MY_C_FLAGS "-O -Wall -Wextra -Werror -ansi -pedantic")
5. set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${MY_C_FLAGS}")
```

Like a regular language, CMake uses variables to keep track of certain information. This is what the following are; MY_C_FLAGS, CMAKE_C_FLAGS. They are just variables/definitions.


### References

[CMake](https://cmake.org/)

[CMake Commands](https://cmake.org/cmake/help/v3.0/manual/cmake-commands.7.html)

[CMake Useful Variables](https://cmake.org/Wiki/CMake_Useful_Variables)

[CMake Howto](https://www.cs.swarthmore.edu/~adanner/tips/cmake.php)

[Adding Flags With CMake](http://stackoverflow.com/questions/11783932/how-to-add-linker-or-compile-flag-in-cmake-file)
